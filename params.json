{"name":"ConfigMapper","tagline":"Simple .NET config to object mapping","body":"### Install from [NuGet](https://www.nuget.org/packages/ConfigMapper)\r\n\r\n```\r\nPM> Install-Package ConfigMapper\r\n```\r\n\r\nConfigMapper for .NET provides interfaced configuration objects with properties mapped from ```appSettings```, allowing your ```IConfiguration``` to be injected anywhere in your code in a unit-testable manner.\r\n\r\n\r\n####Usage\r\n\r\n\r\n```\r\npublic interface IConfiguration\r\n{\r\n    string KeyInAppSettings { get; }\r\n    decimal WorksWithManyTypes { get; }\r\n    MyEnum AlsoWorksWithEnums { get; }\r\n}\r\n\r\nIConfiguration configuration = ConfigMapper.Map<IConfiguration>();\r\n```\r\n\r\nUsage is simple. Configure your DI to inject ```IConfiguration``` using the Map method into any class. The code above assumes we defined ```MyEnum``` somewhere and we have our config file as:\r\n```\r\n<appSettings>\r\n  <add key=\"KeyInAppSettings\" value=\"Foo\"/>\r\n  <add key=\"WorksWithManyTypes\" value=\"42.0\"/>\r\n  <add key=\"AlsoWorksWithEnums\" value=\"Bar\"/>\r\n</appSettings>\r\n```\r\n\r\nAnything the System.Convert class can handle is accepted, in addition to enums.\r\n\r\n#### Efficiency\r\n\r\nConfigMapper is thread-safe, and only one concrete instance from an interface is ever generated, meaning you can call the ```Map<T>``` method any number of times in your code without increased memory usage.\r\n\r\n#### Config Change Handling\r\n\r\nCall ```ConfigMapper.RefreshConfiguration``` if your configuration has changed. Any previously mapped objects will be updated with the latest values from your configuration without needing to re-map them.","google":"UA-54893147-1","note":"Don't delete this file! It's used internally to help with page regeneration."}